% The predictive capacity of each model generated by driver_createMultipleIDNModels
% is evaluated using the modelPredictiveCapacity function to identify the
% model and objective with the highest accuracy.
% The features to consider are the flux consistency  of reactions and metabolites,
% the predictive capacity of uptakes and secretions, the Euclidean distance to the
% experimental values, the number of metabolites, and the number of reactions.
% Save the results as accuracy.mat in each directory
%
% The models are saved in:
% ~/work/sbgCloud/programReconstruction/projects/exoMetDN/results/multidimensionalModelGeneration

clear

% Define results directory
if ~contains(char(java.lang.System.getProperty('user.name')),'rfleming')
    modelsDir = pwd;
    pathSave = pwd;
    matFileName = 'multidimensionalComparisonStats';
else
    modelsDir = ['~' filesep 'work' filesep 'sbgCloud' filesep 'programReconstruction' ...
        filesep 'projects' filesep 'exoMetDN' filesep 'results' filesep 'qualitativeBest'];
    pathSave = ['~' filesep 'work' filesep 'sbgCloud' filesep 'programReconstruction' ...
        filesep 'projects' filesep 'exoMetDN' filesep 'results' filesep 'qualitativeBest'];
    matFileName = 'multidimensionalComparisonStatsSingle';
end

% Get a list of all files and folders in this folder.
directoriesWithModels = dir(modelsDir);
directoriesWithModels = struct2cell(directoriesWithModels([directoriesWithModels.isdir]));
directoriesWithModels = directoriesWithModels(1, 3:end)';

%% multidimentionalComparisonStats

% Prepare the table with the accuracy data
objectives =  {'unWeighted0norm'; 'Weighted0normGE'; 'unWeighted1norm'; 'Weighted1normGE';...
    'unWeighted2norm'; 'Weighted2normGE'; 'unWeightedTCBMflux'; 'unWeightedTCBMfluxConc'};
nRows = length(directoriesWithModels) * length(objectives);
varTypes = {'double', 'string', 'string', 'string', 'string', 'string',...
    'string', 'string', 'string', 'string', 'double', 'double', 'double',...
    'double', 'double', 'double', 'double', 'double', 'double', 'double', ...
    'double', 'double', 'string'};
varNames = {'modelId', 'dirName', 'tissueSpecificSolver', 'activeGenesApproach',...
    'transcriptomicThreshold', 'limitBounds', 'genesTranscriptomics', 'ions', ...
    'preferenceCurationOrOmics', 'objective', 'qualitativeBoth', 'quantitativeBoth',...
    'spearmanBoth', 'qualitativeModelSec', 'quantitativeModelSec', 'spearmanModelSec', ...
    'quantitativeModelUpt', 'qualitativeModelUpt', 'spearmanModelUpt', 'nOfmets', ...
    'nOfrxns', 'rankOfS', 'ME'};
multidimensionalComparisonStats = table('Size', [nRows length(varTypes)], 'VariableTypes', varTypes,...
    'VariableNames', varNames);

% 

if ~isfile([pathSave filesep matFileName '.mat'])
    
    display('Testing qualitative and quantitative predictive capacity ...')
    
    % Select solver
    [~, ~] = changeCobraSolver('gurobi', 'all', 0);
    
    c = 0;
    for i = 1:size(directoriesWithModels, 1)
        
        workingDirectory = [modelsDir filesep directoriesWithModels{i} filesep];
        
        if isfile([workingDirectory 'Model.mat'])
            % Identify number dimensions
            load([workingDirectory 'Model.mat'])
            model = Model;
            numberOfMets = length(model.mets);
            numberOfRxns = length(model.rxns);
            rankOfS = rank(full(model.S));
            
            if isfile([workingDirectory 'accuracy.mat'])
                load([workingDirectory 'accuracy.mat'], 'comparisonData')
            else
                % Set parameters
                param.tests = 'flux';
                param.activeInactiveRxn = model.activeInactiveRxn;
                param.presentAbsentMet = model.presentAbsentMet;
                param.trainingSet = model.XomicsToModelSpecificData.exoMet;
                param.objectives = objetives;
                param.printLevel = 0;
                
                % test modelPredictiveCapacity
                [comparisonData, summary] = modelPredictiveCapacity(model, param);
                save([workingDirectory 'accuracy.mat'], 'comparisonData', 'summary')
            end
            
            % Split conditions
            directoriesComparison = split(directoriesWithModels{i}, '_');
            
            for j = 1:length(objectives)
                
                c = c + 1;
                
                % Assign conditions
                multidimensionalComparisonStats.modelId(c) = i;
                multidimensionalComparisonStats.dirName(c) = directoriesWithModels{i};
                idIdx = ismember(directoriesComparison, {'fastCore'; 'thermoKernel'});
                multidimensionalComparisonStats.tissueSpecificSolver(c) = directoriesComparison(idIdx);
                idIdx = ismember(directoriesComparison, {'deleteModelGenes', 'oneRxnPerActiveGene'});
                multidimensionalComparisonStats.activeGenesApproach(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'transcriptomicsT'});
                multidimensionalComparisonStats.transcriptomicThreshold(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'limitBoundary'});
                multidimensionalComparisonStats.limitBounds(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'nactiveGenesT'});
                multidimensionalComparisonStats.genesTranscriptomics(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'Ions'});
                multidimensionalComparisonStats.ions(c) = directoriesComparison(idIdx);
                idIdx = ismember(directoriesComparison, {'curationOverOmics', 'omicsOverCuration'});
                multidimensionalComparisonStats.preferenceCurationOrOmics(c) = directoriesComparison(idIdx);
                
                % Assign objective
                multidimensionalComparisonStats.objective(c) = objectives(j);
                
                % Quantitative and qualitative
                multidimensionalComparisonStats.qualitativeBoth(c) = comparisonData.comparisonStats.accuracy(strcmp(comparisonData.comparisonStats.model, 'both') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.quantitativeBoth(c) = comparisonData.comparisonStats.wEuclidNorm(strcmp(comparisonData.comparisonStats.model, 'both') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.spearmanBoth(c) = comparisonData.comparisonStats.spearman(strcmp(comparisonData.comparisonStats.model, 'both') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.qualitativeModelSec(c) = comparisonData.comparisonStats.accuracy(strcmp(comparisonData.comparisonStats.model, 'modelSec') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.quantitativeModelSec(c) = comparisonData.comparisonStats.wEuclidNorm(strcmp(comparisonData.comparisonStats.model, 'modelSec') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.spearmanModelSec(c) = comparisonData.comparisonStats.spearman(strcmp(comparisonData.comparisonStats.model, 'modelSec') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.qualitativeModelUpt(c) = comparisonData.comparisonStats.accuracy(strcmp(comparisonData.comparisonStats.model, 'modelUpt') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.quantitativeModelUpt(c) = comparisonData.comparisonStats.wEuclidNorm(strcmp(comparisonData.comparisonStats.model, 'modelUpt') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                multidimensionalComparisonStats.spearmanModelUpt(c) = comparisonData.comparisonStats.spearman(strcmp(comparisonData.comparisonStats.model, 'modelUpt') & strcmp(comparisonData.comparisonStats.objective, objectives{j}));
                
                % Error messages
                objectiveBool = contains(comparisonData.fullReport.objective, objectives(j));
                ME = unique(rmmissing(comparisonData.fullReport.messages(objectiveBool)));
                if ~isempty(ME)
                    multidimensionalComparisonStats.ME(c) = strjoin(unique(rmmissing(comparisonData.fullReport.messages(objectiveBool))));
                end
                
                % Dimensions
                multidimensionalComparisonStats.nOfmets(c) = numberOfMets;
                multidimensionalComparisonStats.nOfrxns(c) = numberOfRxns;
                multidimensionalComparisonStats.rankOfS(c) = rankOfS;
                
            end
          
        else % A model wasn't generated
            
            % Split conditions
            directoriesComparison = split(directoriesWithModels{i}, '_');
            
            for j = 1:length(objectives)
                
                c = c + 1;
                
                % Assign conditions
                multidimensionalComparisonStats.modelId(c) = i;
                multidimensionalComparisonStats.dirName(c) = directoriesWithModels{i};
                idIdx = ismember(directoriesComparison, {'fastCore'; 'thermoKernel'});
                multidimensionalComparisonStats.tissueSpecificSolver(c) = directoriesComparison(idIdx);
                idIdx = ismember(directoriesComparison, {'deleteModelGenes', 'oneRxnPerActiveGene'});
                multidimensionalComparisonStats.activeGenesApproach(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'transcriptomicsT'});
                multidimensionalComparisonStats.transcriptomicThreshold(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'limitBoundary'});
                multidimensionalComparisonStats.limitBounds(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'nactiveGenesT'});
                multidimensionalComparisonStats.genesTranscriptomics(c) = directoriesComparison(idIdx);
                idIdx = contains(directoriesComparison, {'Ions'});
                multidimensionalComparisonStats.ions(c) = directoriesComparison(idIdx);
                idIdx = ismember(directoriesComparison, {'curationOverOmics', 'omicsOverCuration'});
                multidimensionalComparisonStats.preferenceCurationOrOmics(c) = directoriesComparison(idIdx);
                
                % Assign objective
                multidimensionalComparisonStats.objective(c) = objectives(j);
                
                % Quantitative and qualitative
                multidimensionalComparisonStats.qualitativeBoth(c) = NaN;
                multidimensionalComparisonStats.quantitativeBoth(c) = NaN;
                multidimensionalComparisonStats.spearmanBoth(c) = NaN;
                multidimensionalComparisonStats.qualitativeModelSec(c) = NaN;
                multidimensionalComparisonStats.quantitativeModelSec(c) = NaN;
                multidimensionalComparisonStats.spearmanModelSec(c) = NaN;
                multidimensionalComparisonStats.qualitativeModelUpt(c) = NaN;
                multidimensionalComparisonStats.quantitativeModelUpt(c) = NaN;
                multidimensionalComparisonStats.spearmanModelUpt(c) = NaN;
                
                % Error messages
                multidimensionalComparisonStats.ME(c) = 'The model was not created';
                
                % Dimensions
                multidimensionalComparisonStats.nOfmets(c) = NaN;
                multidimensionalComparisonStats.nOfrxns(c) = NaN;
                multidimensionalComparisonStats.rankOfS(c) = NaN;
            end
        end
    end
    
    save([pathSave filesep matFileName '.mat'], ...
        'multidimensionalComparisonStats')
else
    load([pathSave filesep matFileName '.mat'])
end


display('Model''s predictive capacity tested')
display('Results saved in:')
display([pathSave filesep matFileName '.mat'])

%% Test
if 0
    r = randi([1, length(directoriesWithModels)] , 10, 1);
    for i = 1:10
        
        workingDirectory = [modelsDir filesep directoriesWithModels{r(i)} filesep];
        
        load([workingDirectory 'Model.mat'])
        load([workingDirectory 'accuracy.mat'])
        
        comparisonDataBool = strcmp(comparisonData.comparisonStats.model, 'both');
        randomModelAccuracy = comparisonData.comparisonStats.accuracy(comparisonDataBool);
        randomModelAccuracy(isnan(randomModelAccuracy)) = [];
        
        mdcsBool = strcmp(multidimensionalComparisonStats.dirName, directoriesWithModels{r(i)});
        mdcsAccuracy = multidimensionalComparisonStats.qualitativeBoth(mdcsBool);
        mdcsAccuracy(isnan(mdcsAccuracy)) = [];
        
        assert(isequal(sort(mdcsAccuracy), sort(randomModelAccuracy)), 'The accuracy is different')
        
    end
end
