% Driver to create a context-specific genome-scale model of km_ha cell line
% based on transcriptomic data. Two models are merged to obtain a generic
% metabolic network. km_ha was generated by merlin iv and a published yeast
% model.
%
% Yeast model
% https://github.com/SysBioChalmers/yeast-GEM
%
% Sources of interest:
% https://www.nature.com/articles/s41467-021-25158-6#data-availability

%% Initialise

clear

% Define directories
filePath = regexprep(matlab.desktop.editor.getActiveFilename, 'yeastBased.m', '');
dataDir = [filePath filesep 'data' filesep];
outputDir = [filePath 'results' filesep];

if ~isfile([outputDir '1stSection.mat'])
    
    % Read models
    
    % km_ha
    km_ha = readCbModel([dataDir 'km_ha.xml'],'fileType','SBML','defaultBound', 1000);
    km_ha.grRules = km_ha.rules;
    % yeast model
    load([dataDir 'yeast-GEM.mat'])
    yeastModel = model;
    % Size of S in km_ha:       1228 x 1053
    % Size of S in yeast model: 2744 x 4063
    
    % Cambiar solver
    [~, ~] = changeCobraSolver('mosek', 'all');
    
    % Save debug file
    clear model
    save([outputDir '1stSection.mat'])
    
end

%% Change to mets and rxns names to BiGGids

clearvars -except outputDir

if ~isfile([outputDir '2ndSection.mat'])
    
    load([outputDir '1stSection.mat'])
    
    % Add BiGG ids in the yeast model
    % Read Ids
    yeastBiggRxns = readtable([dataDir 'BiGGrxnDictionary.csv']);
    yeastBiggMets = readtable([dataDir 'BiGGmetDictionary.csv']);
    % mets
    [~, locb] = ismember(yeastModel.mets, regexprep(yeastBiggMets.mets, '(\[\w\])', ''));
    yeastModel.metBiGGID = cell(length(locb), 1);
    for i = 1:length(locb)
        yeastModel.metBiGGID{i} = '';
        if locb(i) ~= 0
            yeastModel.metBiGGID(i) = yeastBiggMets.bigg(locb(i));
        end
    end
    % rxns
    [~, locb] = ismember(yeastModel.rxns, yeastBiggRxns.rxns);
    yeastModel.rxnBiGGID = cell(length(locb), 1);
    for i = 1:length(locb)
        yeastModel.rxnBiGGID{i} = '';
        if locb(i) ~= 0
            yeastModel.rxnBiGGID(i) = yeastBiggRxns.bigg(locb(i));
        end
    end
    
    % Change ids to BiGG id in the Yeast model
    % Mets
    for i = 1:length(yeastModel.mets)
        if ~isempty(yeastModel.metBiGGID{i})
            yeastModel.mets{i} = [yeastModel.metBiGGID{i} '[' yeastModel.comps{yeastModel.metComps(i)} ']'];
        else
            yeastModel.mets{i} = [yeastModel.mets{i} '[' yeastModel.comps{yeastModel.metComps(i)} ']'];
        end
    end
    % Rxns
    for i = 1:length(yeastModel.rxns)
        if ~isempty(yeastModel.rxnBiGGID{i})
            yeastModel.rxns{i} = yeastModel.rxnBiGGID{i};
        end
    end
    yeastModel = alphabetizeModel(yeastModel);
    yeastModel.rxnsFormulas = printRxnFormula(yeastModel, 'printFlag', 0);
    
    % Change ids to BiGG id in the km_ha model
    % Mets
    for i = 1:length(km_ha.mets)
        comp = regexp(km_ha.mets{i}, '(\[\w\d\])', 'match', 'once');
        if ~isempty(km_ha.metBiGGID{i})
            mets = split(km_ha.metBiGGID{i}, '; ');
            met = mets{1};
            if length(mets) > 1
                metIdx = find(ismember(mets, yeastModel.metBiGGID));
                if ~isempty(metIdx)
                    met = mets{metIdx};
                end
            end
            km_ha.mets{i} = [met comp];
        end
    end
    % Rxns
    for i = 1:length(km_ha.rxns)
        if ~isempty(km_ha.rxnBiGGID{i})
            rxns = split(km_ha.rxnBiGGID{i}, '; ');
            km_ha.rxns{i} = rxns{1};
        end
    end
    km_ha = alphabetizeModel(km_ha);
    km_ha.rxnsFormulas = printRxnFormula(km_ha, 'printFlag', 0);
    
    % Save debug file
    save([outputDir '2ndSection.mat'])
    
end

%% Identify reacctions present in both models

clearvars -except outputDir

if ~isfile([outputDir '3rdSection.mat'])
    
    load([outputDir '2ndSection.mat'])
    
    % By BiGG ID
    rxns2Remove = [];
    BiGGIds = [];
    for i = 1:length(km_ha.rxns)
        rxns = split(km_ha.rxnBiGGID{i}, '; ');
        
        for j = 1:length(rxns)
            
            if ismember(rxns{j} , yeastModel.rxns)
                rxns2Remove = [rxns2Remove; km_ha.rxns(i)];
                BiGGIds = [BiGGIds rxns(j)];
            end
        end
    end
    [km_ha, ~, ~] = removeRxns(km_ha, rxns2Remove);
    
    % By rxnFormula
    rxns2Remove = [];
    inYeastFormulas = [];
    yeastFormulas = regexprep(strtrim(regexprep(yeastModel.rxnsFormulas, '(\[\w+])', '')), '  ', ' ');
    for i = 1:length(km_ha.rxns)
        formula_km_ha = regexprep(strtrim(regexprep(km_ha.rxnsFormulas{i}, '(\[\w\d\])', '')), '  ', ' ');
        if ismember(formula_km_ha, yeastFormulas)
            rxns2Remove = [rxns2Remove; km_ha.rxns(i)];
            inYeastFormulas = [inYeastFormulas yeastModel.rxns(ismember(yeastFormulas, formula_km_ha))'];
        end
    end
    [km_ha, ~, ~] = removeRxns(km_ha, rxns2Remove);
    
    % By EC number (none)
    rxns2Remove = [];
    EcNumberRepeated = [];
    ecnumber = [];
    for i = length(yeastModel.eccodes)
        eccodesYeast = split(yeastModel.eccodes{i}, ';');
        for j = 1:length(km_ha.rxnECNumbers)
            eccodesKm_ha = split(km_ha.rxnECNumbers{j}, '; ');
            for k = 1:length(eccodesYeast)
                if ismember(eccodesYeast(k), eccodesKm_ha)  && ~isempty(eccodesYeast{k})
                    rxns2Remove = [rxns2Remove km_ha.rxns(j)];
                    EcNumberRepeated = [EcNumberRepeated yeastModel.rxns(i)];
                end
            end
        end
    end
    if ~isempty(rxns2Remove)
        [km_ha, ~, ~] = removeRxns(km_ha, rxns2Remove);
    end
    
    % Add prefix to reactions in both
    reactionsInBoth = findRxnIDs(yeastModel, unique([BiGGIds EcNumberRepeated inYeastFormulas]));
    for i = 1:length(reactionsInBoth)
        yeastModel.rxns{reactionsInBoth(i)} = ['both_' yeastModel.rxns{reactionsInBoth(i)}];
    end
    
    % Save debug file
    save([outputDir '3rdSection.mat'])
    
end
%% Create a table with missing reactions

clearvars -except outputDir

load([outputDir '3rdSection.mat'])

% Create the table
nRows = length(km_ha.rxns);
varTypes = {'string', 'string', 'string', 'string'};
varNames = {'rxns', 'compartment', 'rxnFormulas', 'rxnNames'};
rxnsTable = table('Size', [nRows length(varTypes)], 'VariableTypes', varTypes,...
    'VariableNames', varNames);

% Fill the table
rxnsTable.rxns = km_ha.rxns;
rxnsTable.compartment = cellfun(@strjoin, cellfun(@unique, ...
    regexp(km_ha.rxnsFormulas, '(\[\w\d\])', 'match'), 'UniformOutput',...
    false), 'UniformOutput', false);
rxnsTable.rxnFormulas = km_ha.rxnsFormulas;
rxnsTable.rxnNames = km_ha.rxnNames;

%% Add missing reactions with the correct compartment
% z6 = p
% z5 = n

clearvars -except outputDir

load([outputDir '3rdSection.mat'])

km_ha.mets = regexprep(km_ha.mets, '\[c0\]', '\[c\]');
km_ha.mets = regexprep(km_ha.mets, '\[e0\]', '\[e\]');
km_ha.mets = regexprep(km_ha.mets, '\[z5\]', '\[n\]');
km_ha.mets = regexprep(km_ha.mets, '\[z6\]', '\[p\]');
km_ha.mets = regexprep(km_ha.mets, '\[g0\]', '\[g\]');
km_ha.mets = regexprep(km_ha.mets, '\[m0\]', '\[m\]');
km_ha.mets = regexprep(km_ha.mets, '\[r0\]', '\[r\]');
km_ha.mets = regexprep(km_ha.mets, '\[z7\]', '\[v\]');
km_ha.rxnsFormulas = printRxnFormula(km_ha, 'printFlag', 0);

for i = 1:length(km_ha.rxns)
    if ~ismember(['origKmha_' km_ha.rxns{i}], yeastModel.rxns)
        yeastModel = addReaction(yeastModel, ['origKmha_' km_ha.rxns{i}], ...
            'reactionFormula', km_ha.rxnsFormulas{i}, ...
            'reactionName', km_ha.rxnNames{i}, ...
            'lowerBound', km_ha.lb(i), ...
            'upperBound', km_ha.ub(i), ...
            'geneRule', km_ha.grRules{i});
        yeastModel.eccodes(length(yeastModel.rxns), 1) = km_ha.rxnECNumbers(i);
    end
end

yeastModel = alphabetizeModel(yeastModel);
yeastModel.rxnsFormulas = printRxnFormula(yeastModel, 'printFlag', 0);

%% Biomass reaction
%
% S = full(km_ha.S);
% setdiff(regexprep(km_ha.mets(find(S(:, end))), '(\[\w+])', ''), ...
%     regexprep(yeastModel.mets, '(\[\w+])', ''));
%

%% Stoichiometric, tharmodynamic and flux consistent model


% specificData.activeReactions = yeastModel.rxns(contains(yeastModel.rxns, 'origKmha_') | contains(yeastModel.rxns, 'both_'));
% specificData.rxns2remove.rxns = {'ACACT2'; 'DHAPtlp'; 'ABTDG'; 'DEDGGLHO12'};
% specificData.transcriptomicData.genes = string(specificData.transcriptomicData.genes);
% specificData.transcriptomicData.genes(1:length(km_ha.genes)) = km_ha.genes;

% XomicsToModel
% General parameters
param.workingDirectory = outputDir;
param.printLevel = 2;
param.setObjective = ''; % No objective function
feasTol = getCobraSolverParams('LP', 'feasTol');
param.boundPrecisionLimit = feasTol * 10;
param.fluxEpsilon = feasTol * 10;
param.fluxCCmethod = 'fastcc';
param.weightsFromOmics = 1;
param.metabolomicWeights = 'mean';
param.sinkDMinactive = 1; % Set non-core sinks and demands to inactive
param.addCoupledRxns = 1;
param.nonCoreSinksDemands = 'closeAll';
param.closeUptakes = true; % Cell culture information
param.debug = true;
param.tissueSpecificSolver = 'thermoKernel';
param.activeGenesApproach = 'oneRxnPerActiveGene'; % {'deleteModelGenes', 'oneRxnPerActiveGene'};
param.transcriptomicThreshold = 2; % [0 1 2];
param.TolMinBoundary = -1e4;
param.TolMaxBoundary = 1e4;
param.inactiveGenesTranscriptomics = true; % [true false];
param.closeIons = false; % [true false];

% Correr la funcion
[km_haNew, ~] = XomicsToModel(yeastModel, specificData, param);

% Salvar modelo
save([outputDir filesep 'km_haNew.mat'], 'km_haNew')
